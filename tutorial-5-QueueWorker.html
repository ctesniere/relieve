<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: 5-QueueWorker</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: 5-QueueWorker</h1>

    <section>

<header>
    

    <h2>5-QueueWorker</h2>
</header>

<article>
    <p>The <a href="module-workers_QueueWorker-QueueWorker.html">QueueWorker</a> does not accept ForkTasks. It will handle start/stop action, and therefore when a Task is added it must not be started.</p>
<p>The QueueWorker expect tasks to exit once their job is done, it'll then start queued tasks according to the concurrency setting.
If you want to run things in series or in parallel, you'll have to set the according concurrency. For example, having a concurrency to 1 will run each task when the previous one exits. On the other hand, setting concurrency to 10 will run at most 10 tasks at once.</p>
<p>For example:</p>
<pre class="prettyprint source"><code>var relieve = require('relieve')
var ScriptTask = relieve.tasks.ScriptTask
var QueueWorker = relieve.workers.QueueWorker

var worker = new QueueWorker({concurrency: 10})

worker
.add(new ScriptTask('sometask.js'))
.add(new ScriptTask('sometask.js'))

worker.run()
//each task has exit, we can remove them from the worker
.then(function() {
  for(let t of worker.tasks) {
    worker.remove(t.name)
  }
})</code></pre><p>You can find working use cases <a href="./usecases">here</a>.</p>
<h3>Compressing Task</h3><pre class="prettyprint source lang-javascript"><code>//task.js
'use strict';
var archiver = require('archiver')
var fs = require('fs')
var channel = process.relieve.ipc

module.exports = {
  start: function() {
    var archive = archiver('zip')
    var action = process.argv[3]
    var output = fs.createWriteStream(action.dest)

    output.on('close', function() {
      channel.send('finish', archive.pointer() + ' bytes written')
      process.exit(0) //Note that we exit this tasks when it's done
    })

    archive.on('error', function(err) { throw err })
    archive.pipe(output)
    archive.bulk([action.src])
    archive.finalize()
  }
}</code></pre><p>This task, when started, will compress things we gave through the task arguments. The QueueWorker will be able to run lots of those in separated processes.</p>
<pre class="prettyprint source lang-javascript"><code>'use strict';
var relieve = require('relieve')
var ScriptTask = relieve.tasks.ScriptTask
var QueueWorker = relieve.workers.QueueWorker

var worker = new QueueWorker({concurrency: 10})

//assuming that I have a request for 5 compressions
var actions = [
  {src: ['fixtures/somepath', 'fixtures/somedir/'], dest: 'one.zip'},
  {src: ['fixtures/foo'], dest: 'two.zip'},
  {src: ['fixtures/bar'], dest: 'three.zip'},
  {src: ['fixtures/video.mkv', 'fixtures/audio.mp3'], dest: 'four.zip'},
  {src: ['fixtures/directory/*'], dest: 'five.zip'},
]

//I'm creating one task per action
for(let i in actions) {
  var task = new ScriptTask(__dirname + '/task.js')
  task.name = actions[i].dest //the name is the destination name
  task.arguments = [actions[i]] //give my action as arguments to the task

  worker.add(task)
}

//compress everything
worker.run()
//remove tasks when done
.then(function() {
  for(let t of worker.tasks) {
    worker.remove(t.name)
  }
})</code></pre><h3>Cksfv</h3><p><code>cksfv</code> is a tool that compares CRC hashes. It is commonly used to check the integrity of a multi-part rar file. It works by calculating the hash of each file and comparing the hash to the expected one.
This example shows how the QueueWorker can be used to share a cpu-intensive task through multiple process. My benchmarks shows an improvement with many large parts, it won't show improvements with small parts (ie &lt; 100mb).</p>
<p>For example, using 50 250mb parts, having a 20 concurrency:</p>
<ul>
<li>without workers 832125ms (13.8 min), cpu use is about 32% on one process</li>
<li>without workers 225141ms (3.75 min), cpu use is about 2% on each of the 20 child processes</li>
</ul>
<p>The Task:</p>
<pre class="prettyprint source"><code>//task.js
'use strict';
var channel = process.relieve.ipc
var readLine = require('./readLine.js')

module.exports = {
  readLine: function(path, line) {
    readLine(path, line)
    .then(function(resp) {
      channel.send('cksfv', resp)
      process.exit(0)
    })
  }
}</code></pre><p>This is the part that calculates the CRC hash:</p>
<pre class="prettyprint source"><code>//readLine.js
'use strict';
var Promise = require('bluebird')
var crc = require('crc')
var fs = Promise.promisifyAll(require('fs'))
var p = require('path')

function readLine(path, line) {
  if(!line.trim())
    return Promise.resolve()

  var original = line.trim().slice(-8)
  var filepath = line.slice(0, -9).trim()
  var resp = {original: original, filepath: filepath}

  console.log('Processsing %s', p.resolve(p.dirname(path), filepath))

  return fs.readFileAsync(p.resolve(p.dirname(path), filepath))
  .then(function(buffer) {
    var str = crc.crc32(buffer).toString(16)

    while(str.length &lt; 8) {
      str = '0'+str
    }

    resp.calculate = str

    return resp
  })
}

module.exports = readLine</code></pre><p>The Worker reads the <code>.sfv</code> file and sends every line to a new Task.</p>
<p>It's then executed with: <code>node worker.js path/to/file.sfv</code>.</p>
<pre class="prettyprint source"><code>//worker.js
'use strict';
var relieve = require('relieve')
var assert = require('assert')
var Promise = require('bluebird')
var p = require('path')
var fs = Promise.promisifyAll(require('fs'))
var eol = require('os').EOL
var CallableTask = relieve.tasks.CallableTask
var QueueWorker = relieve.workers.QueueWorker

assert.ok(
  typeof process.argv[2] == 'string' && p.extname(process.argv[2]) == '.sfv',
  'Sfv file must be provided'
);

var path = process.argv[2]
var map = []

//Call my task method
function call(line) {
  return function() {
    worker.task(line).call('readLine', path, line)
  }
}

var worker = new QueueWorker({concurrency: 20})

console.time('cksfv')

fs.readFileAsync(path)
.then(function(data) {
  data = data.toString()
    .split(eol)
    .map(e => e.trim())
    .filter(e => e.length)

  //Creates tasks for each lines, those are not started yet
  data.map(function(line) {
    let task = new CallableTask(__dirname + '/task.js')
    task.name = line
    task.once('start', call(line))
    task.once('cksfv', function(resp) {
      map.push(resp)
    })
    worker.add(task)
  })

  //Here we start tasks keeping a 20 concurrency
  worker.run()
  .then(function() {
    let errors = 0
    for(let i in map) {
      if(map[i].original != map[i].calculate) {
        console.error('File %s does not match crc', map[i].filepath)
        errors++
      }
    }

    console.log('Done checking with %d errors', errors)
    console.timeEnd('cksfv')
  })
})</code></pre>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-containers_CallableContainer.html">containers/CallableContainer</a></li><li><a href="module-containers_ScriptContainer.html">containers/ScriptContainer</a></li><li><a href="module-strategies_WeightedStrategy.html">strategies/WeightedStrategy</a></li><li><a href="module-tasks_CallableTask.html">tasks/CallableTask</a></li><li><a href="module-tasks_ForkTask.html">tasks/ForkTask</a></li><li><a href="module-tasks_ScriptTask.html">tasks/ScriptTask</a></li><li><a href="module-workers_CloudWorker.html">workers/CloudWorker</a></li><li><a href="module-workers_QueueWorker.html">workers/QueueWorker</a></li><li><a href="module-workers_Worker.html">workers/Worker</a></li></ul><h3>Classes</h3><ul><li><a href="module-tasks_CallableTask-CallableTask.html">CallableTask</a></li><li><a href="module-tasks_ForkTask-ForkTask.html">ForkTask</a></li><li><a href="module-tasks_ScriptTask-ScriptTask.html">ScriptTask</a></li><li><a href="module-workers_CloudWorker-CloudWorker.html">CloudWorker</a></li><li><a href="module-workers_QueueWorker-QueueWorker.html">QueueWorker</a></li><li><a href="module-workers_Worker-Worker.html">Worker</a></li></ul><h3>Events</h3><ul><li><a href="module-tasks_CallableTask-CallableTask.html#event:exit">exit</a></li><li><a href="module-tasks_ScriptTask-ScriptTask.html#event:exit">exit</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-1-ForkTask.html">1-ForkTask</a></li><li><a href="tutorial-2-ScriptTask.html">2-ScriptTask</a></li><li><a href="tutorial-3-CallableTask.html">3-CallableTask</a></li><li><a href="tutorial-4-Worker.html">4-Worker</a></li><li><a href="tutorial-5-QueueWorker.html">5-QueueWorker</a></li><li><a href="tutorial-6-CloudWorker.html">6-CloudWorker</a></li><li><a href="tutorial-7-Containers.html">7-Containers</a></li><li><a href="tutorial-8-Interfaces.html">8-Interfaces</a></li></ul><h3>Global</h3><ul><li><a href="global.html#defineNameProperty">defineNameProperty</a></li><li><a href="global.html#listenersPropagation">listenersPropagation</a></li><li><a href="global.html#readOnly">readOnly</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Mar 10 2017 17:52:16 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>